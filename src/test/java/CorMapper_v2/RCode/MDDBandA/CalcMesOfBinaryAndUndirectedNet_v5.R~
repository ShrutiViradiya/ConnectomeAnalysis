# Usage:
# % Rscript calc_brain_network_mes.R {folder that includes mtx files} {ouput file name} {# of randomized networks} {# of threads for parallel computing}
# このファイルは「C:\Users\issey\Documents\Dropbox\docroot\pipeline4brain_net_v2\calc_brain_network_mes.R」をコピーし改造したもの。
#
# 使用例：
# 
# Rscript CalcMesOfBinaryAndUndirectedNet_v4.R ../wd_AD_vs_NML_deep/binary_undirected/ 1
# Rscript CalcMesOfBinaryAndUndirectedNet_v4.R ../wd_AD_vs_cMCI_deep/binary_undirected/ 1
# Rscript CalcMesOfBinaryAndUndirectedNet_v4.R ../wd_AD_vs_ncMCI_deep/binary_undirected/ 1
# Rscript CalcMesOfBinaryAndUndirectedNet_v4.R ../wd_cMCI_vs_NML_deep/binary_undirected/ 1
# Rscript CalcMesOfBinaryAndUndirectedNet_v4.R ../wd_cMCI_vs_ncMCI_deep/binary_undirected/ 1
# Rscript CalcMesOfBinaryAndUndirectedNet_v4.R ../wd_ncMCI_vs_NML_deep/binary_undirected/ 1
#
# Rscript CalcMesOfBinaryAndUndirectedNet_v4.R ../wd_AD_vs_NML_deep+surf/binary_undirected/ 1
# Rscript CalcMesOfBinaryAndUndirectedNet_v4.R ../wd_AD_vs_cMCI_deep+surf/binary_undirected/ 1
# Rscript CalcMesOfBinaryAndUndirectedNet_v4.R ../wd_AD_vs_ncMCI_deep+surf/binary_undirected/ 1
# Rscript CalcMesOfBinaryAndUndirectedNet_v4.R ../wd_cMCI_vs_NML_deep+surf/binary_undirected/ 1
# Rscript CalcMesOfBinaryAndUndirectedNet_v4.R ../wd_cMCI_vs_ncMCI_deep+surf/binary_undirected/ 1
# Rscript CalcMesOfBinaryAndUndirectedNet_v4.R ../wd_ncMCI_vs_NML_deep+surf/binary_undirected/ 1

# Rscript CalcMesOfBinaryAndUndirectedNet_v4.R ../wd_AD_vs_NML_surf/binary_undirected/ 1
# Rscript CalcMesOfBinaryAndUndirectedNet_v4.R ../wd_AD_vs_cMCI_surf/binary_undirected/ 1
# Rscript CalcMesOfBinaryAndUndirectedNet_v4.R ../wd_AD_vs_ncMCI_surf/binary_undirected/ 1
# Rscript CalcMesOfBinaryAndUndirectedNet_v4.R ../wd_cMCI_vs_NML_surf/binary_undirected/ 1
# Rscript CalcMesOfBinaryAndUndirectedNet_v4.R ../wd_cMCI_vs_ncMCI_surf/binary_undirected/ 1
# Rscript CalcMesOfBinaryAndUndirectedNet_v4.R ../wd_ncMCI_vs_NML_surf/binary_undirected/ 1

#Rscript CalcMesOfBinaryAndUndirectedNet_v5.R ../wd_NMLMET_vs_NMLVAL_6nodes/weighted_directed_thresholded/ 1
#Rscript CalcMesOfBinaryAndUndirectedNet_v5.R ./wd_LB_vs_LA_deep+surf/binary_undirected/ 1


library(igraph)
library(gtools)
library(snow)
source("edge_swapping_randomization.R")
source("constants.R")

get_network_mes_null <- function(i){

    # network randomization
    # using configuration model
    #deg <- degree(g)
    #g_rand <- degree.sequence.game(deg,m = "simple.no.multiple")
    #V(g_rand)$name <- V(g)$name

    # using degree-preserving edge swapping algorithm based on Maslov and Sneppen (2002)
    #g_rand <- edge_swapping_randomization(g)

    # using simple degree-preserving edge swapping algorithm
    g_rand <- rewire(g, with=keeping_degseq(niter=ecount(g)*10,loops=F))

    #data <- spinglass.community(g_rand)
    data <- fastgreedy.community(g_rand)
    Q_rand <- max(data$modularity)

    C_rand <- transitivity(g_rand,type="localaverage",isolates="zero")
    L_rand <- average.path.length(g_rand)

    return(c(Q_rand,C_rand,L_rand))
}


# number of randomized networks
#num_rand <- as.numeric(commandArgs()[8])
#num_rand <- 1000
#num_rand <- 100
num_rand <- 10

# number of threads for parallel computing
#n_cluster <- as.numeric(commandArgs()[9])
#n_cluster <- core_count
n_cluster <- 2
cl <- makeCluster(n_cluster, type = "SOCK")

# folder that includes mtx files
folder <- commandArgs()[6]

file_set <- system(paste("ls ",folder,"*.mtx",sep=""),intern=T)
num_subject <- length(file_set)


# ouput file name
#rslt_file_name <- commandArgs()[7]
rslt_file_name <- paste(folder, "../" ,"network_mes_rslt_", basename(folder),".txt", sep="")
cat(rslt_file_name , "へ書き出します。", "\n", sep="")


filename <- file_set[[1]]
d <- as.matrix(read.table(filename,header=T))
g <- simplify(graph.adjacency(d,mode="undirected",weighted=NULL),remove.multiple=T,remove.loops=T)

sort_node_name <- sort(V(g)$name)
node_num <- vcount(g)

#
# variable names: header
#
val_name <- c("network_file","k_ave","H_deg","ACC","APL","Q","Qm","Assort","SW","gEff_ave","lEff_ave")
local_net_mes_name <- c("deg_","cluster_","bet_","closen_","eigen_","page_","hub_","const_","core_","cocite_","gEff_","lEff_")
for(ln in local_net_mes_name){
    for(i in 1:node_num){
        val_name <- c(val_name,paste(ln,sort_node_name[[i]],sep=""))
    }
}
# 開始位置の調整
num_subject <-as.numeric(num_subject)
start <- commandArgs()[7]
start <-as.numeric(start)
#cat("is.numeric(num_subject)=", is.numeric(num_subject), "\n")
if(start==1){
    out <- file(rslt_file_name, "w") #ファイルを書き込みモードで開く（追記モードにしたいなら「a」
    writeLines(paste(val_name, collapse=" "), out, sep="\n")
}else if((start >= 2) && (start <= num_subject)){
    out <- file(rslt_file_name, "a") #ファイルを書き込みモードで開く（追記モードにしたいなら「a」
}else{
    cat("第２引数を確認して下さい。")
    on.exit()
}


combined_data <- c()
for(s in start:num_subject){
    cat(s,"/",num_subject ,"番目のSubjectを処理...", sep=" ")
    # read graph
    filename <- file_set[[s]]
    d <- as.matrix(read.table(filename,header=T))
    g <- simplify(graph.adjacency(d,mode="undirected",weighted=NULL),remove.multiple=T,remove.loops=T)

    ## global network measure

    # degree entropy
    dist <- table(degree(g)) / sum(table(degree(g)))
    H_deg <- -sum(dist * log(dist))

    # modularity
    #data <- spinglass.community(g)
    data <- fastgreedy.community(g)
    Q_real <- max(data$modularity)
    m <- max(data$membership)

    # global (average) clustering coefficient
    C_real <- transitivity(g,type="localaverage",isolates="zero")

    # average shortest path length
    L_real <- average.path.length(g)

    # assortative coefficient
    assort <- assortativity.degree(g)

    # global efficiency
    dist_mtx <- shortest.paths(g)^-1
    diag(dist_mtx) <- 0 #単位行列を作る
    nodal_global_efficiency <- rowSums(dist_mtx) / (node_num - 1) #node_numは脳領域総数。例えば83領域など。
    ave_global_efficiency <- mean(nodal_global_efficiency)

    # local efficiency
    nodal_local_efficiency <- c()
    for(i in 1:node_num){ #node_numは脳領域総数。例えば83領域など。
    nei_idx <- as.vector(neighbors(g,i))
    num_nei <- length(nei_idx)
    if(num_nei > 1) {
        nodal_local_efficiency <- c(nodal_local_efficiency,sum(dist_mtx[permutations(num_nei,2,nei_idx)]) / num_nei / (num_nei - 1))
    }else{
        nodal_local_efficiency <- c(nodal_local_efficiency,0)
    }
    }
    ave_local_efficiency <- mean(nodal_local_efficiency)

    # calc network meastures of null model networks.
    clusterExport(cl, "edge_swapping_randomization")
    clusterExport(cl, "vcount")
    clusterExport(cl, "is.directed")
    clusterExport(cl, "as.directed")
    clusterExport(cl, "delete.edges")
    clusterExport(cl, "E")
    clusterExport(cl, "is.mutual")
    clusterExport(cl, "get.adjacency")
    clusterExport(cl, "get.edgelist")
    clusterExport(cl, "as.undirected")
    clusterExport(cl, "graph.adjacency")
    clusterExport(cl, "ecount")
    clusterExport(cl, "degree")
    clusterExport(cl, "degree.sequence.game")
    clusterExport(cl, "g")
    clusterExport(cl, "simplify")
    clusterExport(cl, "fastgreedy.community")
    clusterExport(cl, "transitivity")
    clusterExport(cl, "average.path.length")
    clusterExport(cl, "V")
    clusterExport(cl, "V<-")
    clusterExport(cl, "rewire")
    clusterExport(cl, "keeping_degseq")

    rand_Q <- as.data.frame(t(parSapply(cl, 1:num_rand, get_network_mes_null)))

    Q_rand <- mean(rand_Q[[1]])
    C_rand <- mean(rand_Q[[2]])
    L_rand <- mean(rand_Q[[3]])

    # connectance
    k_ave <- mean(degree(g))

    # normalized modularity
    Qm <- (Q_real - Q_rand) / (1 - 1 / m - Q_rand)

    # small-worldness
    sw <- (C_real / C_rand) / (L_real / L_rand)

    val <- c(k_ave,H_deg,C_real,L_real,Q_real,Qm,assort,sw,ave_global_efficiency,ave_local_efficiency)

    ## local network measure
    # degree
    deg <- degree(g)
    val <- c(val,deg[order(names(deg))])

    # nodal clustering coefficient
    cluster <- transitivity(g,type="local",isolates="zero")
    names(cluster) <- V(g)$name
    val <- c(val,cluster[order(names(cluster))])

    # betweeness centrality
    bet <- betweenness(g)
    val <- c(val,bet[order(names(bet))])

    # closeness centrality
    closen <- closeness(g)
    val <- c(val,closen[order(names(closen))])

    # eigenvecotr centrality
    eigen <- evcent(g)[[1]]
    val <- c(val,eigen[order(names(eigen))])

    # page-rank
    page <- page.rank(g)[[1]]
    val <- c(val,page[order(names(page))])

    # Hub score
    hubscore <- hub.score(g)$vector
    val <- c(val,hubscore[order(names(hubscore))])

    # Burt's constraint
    constraint <- constraint(g)
    val <- c(val,constraint[order(names(constraint))])

    # Coreness
    coreness <- graph.coreness(g)
    val <- c(val,coreness[order(names(coreness))])

    # Cocitation
    cocitation <- colSums(cocitation(g))
    val <- c(val,cocitation[order(names(cocitation))])

    # nodal global efficiency
    names(nodal_global_efficiency) <- V(g)$name
    val <- c(val,nodal_global_efficiency[order(names(nodal_global_efficiency))])

    # nodal local efficiency
    names(nodal_local_efficiency) <- V(g)$name
    val <- c(val,nodal_local_efficiency[order(names(nodal_local_efficiency))])

    #一列目にファイル名を入れる
    val <- c(basename(filename), val)

    #combined_data <- rbind(combined_data,val)
    writeLines(paste(val, collapse=" "), out, sep="\n")
    cat(s+1,"行目へ書き出し成功","\n", sep="")
}
close(out)

#row.names(combined_data) <- NULL
#combined_data <- data.frame(cbind(basename(file_set),combined_data))
#names(combined_data) <- c(val_name)

#write.table(combined_data, rslt_file_name, quote=F,row.names=F)

